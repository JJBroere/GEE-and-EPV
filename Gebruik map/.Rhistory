GBA <- GB$coefficients
BBAA <-merge(EstimatesB[,i], GBA, by = "row.names", all.x = T,sort=T)
EstimatesBack[,i] <- BBAA$y
}
EstimatesBack[is.na(EstimatesBack)]<- 0#Setting notselected varables to zere
#Calculating model err
EstimatesGEE
MEGEEBACK <- matrix(1,100)
BetaTrue <- c(0.8,0.8,-0.5,-0.5,-0.3,-0.3,0,0,0,0)
for(i in 1:100){
MEGEEBACK[i] <- t(EstimatesBack[,i]-BetaTrue)%*%(EstimatesBack[,i]-BetaTrue)
}
#Calculating model error PGEE
MESCAD <- matrix(1,100)
BetaTrue <- c(0.8,0.8,-0.5,-0.5,-0.3,-0.3,0,0,0,0)
for(i in 1:100){
MESCAD[i] <- t(EstimatesSCAD4010u[,i]-BetaTrue)%*%(EstimatesSCAD4010u[,i]-BetaTrue)
}
MEGEE <- matrix(1,100)
BetaTrue <- c(0.8,0.8,-0.5,-0.5,-0.3,-0.3,0,0,0,0)
for(i in 1:100){
MEGEE[i] <- t(EstimatesGEE[,i]-BetaTrue)%*%(EstimatesGEE[,i]-BetaTrue)
}
mean(MEGEE)
mean(MEGEEBACK)
mean(MESCAD)
EstimatesGEE <- matrix(1,10,100)
for(i in 1:100){
AAB<-summary(geeglm(outcome ~ V2+V3+V4+V5+V6+V7+V8+V9+V10+V11, id= id, data=Sim100N40P10u[[i]], corstr="exchangeable", family = binomial))
EstimatesGEE[,i] <- AAB$coefficients[2:11,1]
}
#Calculating model error for GEE
MEGEE <- matrix(1,100)
BetaTrue <- c(0.8,0.8,-0.5,-0.5,-0.3,-0.3,0,0,0,0)
for(i in 1:100){
MEGEE[i] <- t(EstimatesGEE[,i]-BetaTrue)%*%(EstimatesGEE[,i]-BetaTrue)
}
mean(MEGEE)
RM <-rowMeans(EstimatesGEE)
Bias <- (RM-BetaTrue)/BetaTrue
Bias
data_frame <- Sim100N40P10u[[2]]#dataframe met [id,X,Y]
#settings)
library(matlab)
alpha <- 1 #Eén waarde voor alpha
n_lambda <- 100
lambda_vec <- logspace(-2,5,n_lambda)  #vector of
#PGEE functional settings
a <- 3.7
M_it <- 1000
tresh_beta <- 0.00001
M_diff <- 0.000000000001
k <- 0  #OLS initialization
option <- '' #non adaptive elastic net, no additional weights
method <- 'SCAD'  #method is elastic net as apposed to
p <- 10    #number of variables (all numeric)
distr <- "binomial"
#objecten
conv_mat <- vector(length=n_lambda)
Fit_EN <- array(dim=c(n_lambda,p))
#calculations
for(i_lambda in 1:n_lambda)
{
lambda <- lambda_vec[i_lambda]
fit <- PEE_LI2(data=data_frame,method)
Fit_EN[i_lambda,] <- as.vector(fit$`beta SCAD`)
conv_mat[i_lambda] <- fit$diff_beta
}
#Convergence
max(conv_mat) #no convergence problems
colnames(Fit_EN) <- 1:10#no variable names in artificial example
#selection of variables not always zero
csum <- colSums(Fit_EN)
Fit_EN_select <- Fit_EN[,csum != 0]
#sort on initial size
volg <- order(abs(Fit_EN_select[1,]))
Fit_plot <- Fit_EN_select[,rev(volg)]
#Different results for different lambda's
Fit_plot
#plot tyhe 8 largest ones
linetype <- rep(c(1,2,6),100)
#beta1
plot(x=lambda_vec,y=Fit_plot[,1] ,
type='l',xlab=expression(lambda),ylab=expression(beta),
ylim=c(min(Fit_EN_select),max(Fit_EN_select)),lwd=2,lty=linetype[1],log='x', xlim = c(0.0085,2))
for(i in 2:10)
{
lines(x=lambda_vec,y=Fit_plot[,i],type='l',lwd=2,lty=linetype[i],log='x')
}
setwd("C:/Users/Joris/Google Drive/School/Methodology & Statistics/Master scriptie/Data archief/Gebruik map")
source("Estimators and CV 4 4020u.R")
warnings()
setwd("C:/Users/Joris/Google Drive/School/Methodology & Statistics/Master scriptie/Data archief/Gebruik map")
source("Estimators and CV 4 4020u.R")
data_frame <- Sim100N40P10u[[2]]#dataframe met [id,X,Y]
#settings)
library(matlab)
alpha <- 1 #Eén waarde voor alpha
n_lambda <- 100
lambda_vec <- logspace(-2,5,n_lambda)  #vector of
#PGEE functional settings
a <- 3.7
M_it <- 1000
tresh_beta <- 0.00001
M_diff <- 0.000000000001
k <- 0  #OLS initialization
option <- '' #non adaptive elastic net, no additional weights
method <- 'SCAD'  #method is elastic net as apposed to
p <- 10    #number of variables (all numeric)
distr <- "binomial"
#objecten
conv_mat <- vector(length=n_lambda)
Fit_EN <- array(dim=c(n_lambda,p))
#calculations
for(i_lambda in 1:n_lambda)
{
lambda <- lambda_vec[i_lambda]
fit <- PEE_LI2(data=data_frame,method)
Fit_EN[i_lambda,] <- as.vector(fit$`beta SCAD`)
conv_mat[i_lambda] <- fit$diff_beta
}
#Convergence
max(conv_mat) #no convergence problems
colnames(Fit_EN) <- 1:10#no variable names in artificial example
#selection of variables not always zero
csum <- colSums(Fit_EN)
Fit_EN_select <- Fit_EN[,csum != 0]
#sort on initial size
volg <- order(abs(Fit_EN_select[1,]))
Fit_plot <- Fit_EN_select[,rev(volg)]
#Different results for different lambda's
Fit_plot
#plot tyhe 8 largest ones
linetype <- rep(c(1,2,6),100)
#beta1
plot(x=lambda_vec,y=Fit_plot[,1] ,
type='l',xlab=expression(lambda),ylab=expression(beta),
ylim=c(min(Fit_EN_select),max(Fit_EN_select)),lwd=2,lty=linetype[1],log='x', xlim = c(0.0085,2))
for(i in 2:10)
{
lines(x=lambda_vec,y=Fit_plot[,i],type='l',lwd=2,lty=linetype[i],log='x')
}
data_frame <- Sim100N40P10u[[2]]#dataframe met [id,X,Y]
#settings)
library(matlab)
alpha <- 1 #Eén waarde voor alpha
n_lambda <- 100
lambda_vec <- linspace(0.0025,2,n=n_lambda)  #vector of
#PGEE functional settings
a <- 3.7
M_it <- 1000
tresh_beta <- 0.00001
M_diff <- 0.000000000001
k <- 0  #OLS initialization
option <- '' #non adaptive elastic net, no additional weights
method <- 'SCAD'  #method is elastic net as apposed to
p <- 10    #number of variables (all numeric)
distr <- "binomial"
#objecten
conv_mat <- vector(length=n_lambda)
Fit_EN <- array(dim=c(n_lambda,p))
#calculations
for(i_lambda in 1:n_lambda)
{
lambda <- lambda_vec[i_lambda]
fit <- PEE_LI2(data=data_frame,method)
Fit_EN[i_lambda,] <- as.vector(fit$`beta SCAD`)
conv_mat[i_lambda] <- fit$diff_beta
}
#Convergence
max(conv_mat) #no convergence problems
colnames(Fit_EN) <- 1:10#no variable names in artificial example
#selection of variables not always zero
csum <- colSums(Fit_EN)
Fit_EN_select <- Fit_EN[,csum != 0]
#sort on initial size
volg <- order(abs(Fit_EN_select[1,]))
Fit_plot <- Fit_EN_select[,rev(volg)]
#Different results for different lambda's
Fit_plot
#plot tyhe 8 largest ones
linetype <- rep(c(1,2,6),100)
#beta1
plot(x=lambda_vec,y=Fit_plot[,1] ,
type='l',xlab=expression(lambda),ylab=expression(beta),
ylim=c(min(Fit_EN_select),max(Fit_EN_select)),lwd=2,lty=linetype[1],log='x', xlim = c(0.0085,2))
for(i in 2:10)
{
lines(x=lambda_vec,y=Fit_plot[,i],type='l',lwd=2,lty=linetype[i],log='x')
}
}
data_frame <- Sim100N40P10u[[2]]#dataframe met [id,X,Y]
#settings)
library(matlab)
alpha <- 1 #Eén waarde voor alpha
n_lambda <- 100
lambda_vec <- linspace(0.0025,2,n=n_lambda)  #vector of
#PGEE functional settings
a <- 3.7
M_it <- 1000
tresh_beta <- 0.00001
M_diff <- 0.000000000001
k <- 0  #OLS initialization
option <- '' #non adaptive elastic net, no additional weights
method <- 'SCAD'  #method is elastic net as apposed to
p <- 10    #number of variables (all numeric)
distr <- "binomial"
#objecten
conv_mat <- vector(length=n_lambda)
Fit_EN <- array(dim=c(n_lambda,p))
#calculations
for(i_lambda in 1:n_lambda)
{
lambda <- lambda_vec[i_lambda]
fit <- PEE_LI2(data=data_frame,method)
Fit_EN[i_lambda,] <- as.vector(fit$`beta SCAD`)
conv_mat[i_lambda] <- fit$diff_beta
}
#Convergence
colnames(Fit_EN) <- 1:10#no variable names in artificial example
#selection of variables not always zero
csum <- colSums(Fit_EN)
Fit_EN_select <- Fit_EN[,csum != 0]
max(conv_mat) #no convergence problems
#sort on initial size
volg <- order(abs(Fit_EN_select[1,]))
Fit_plot <- Fit_EN_select[,rev(volg)]
#Different results for different lambda's
Fit_plot
#plot tyhe 8 largest ones
linetype <- rep(c(1,2,6),100)
#beta1
plot(x=lambda_vec,y=Fit_plot[,1] ,
type='l',xlab=expression(lambda),ylab=expression(beta),
ylim=c(min(Fit_EN_select),max(Fit_EN_select)),lwd=2,lty=linetype[1],log='x', xlim = c(0.0085,2))
for(i in 2:10)
{
lines(x=lambda_vec,y=Fit_plot[,i],type='l',lwd=2,lty=linetype[i],log='x')
}
plot(x=lambda_vec,y=Fit_plot[,1] ,
type='l',xlab=expression(lambda),ylab=expression(beta),
ylim=c(min(Fit_EN_select),max(Fit_EN_select)),lwd=2,lty=linetype[1], xlim = c(0.0085,2))
for(i in 2:10)
{
lines(x=lambda_vec,y=Fit_plot[,i],type='l',lwd=2,lty=linetype[i],log='x')
}
plot(x=lambda_vec,y=Fit_plot[,1] ,
type='l',xlab=expression(lambda),ylab=expression(beta),
ylim=c(min(Fit_EN_select),max(Fit_EN_select)),lwd=2,lty=linetype[1], xlim = c(0.0085,0.5))
for(i in 2:10)
{
lines(x=lambda_vec,y=Fit_plot[,i],type='l',lwd=2,lty=linetype[i],log='x')
}
data_frame <- Sim100N40P10u[[1]]#dataframe met [id,X,Y]
data_frame <- Sim100N40P10u[[1]]#dataframe met [id,X,Y]
#settings)
library(matlab)
alpha <- 1 #Eén waarde voor alpha
n_lambda <- 100
lambda_vec <- linspace(0.0025,2,n=n_lambda)  #vector of
#PGEE functional settings
a <- 3.7
M_it <- 1000
tresh_beta <- 0.00001
M_diff <- 0.000000000001
option <- '' #non adaptive elastic net, no additional weights
method <- 'SCAD'  #method is elastic net as apposed to
#objecten
Fit_EN <- array(dim=c(n_lambda,p))
#calculations
for(i_lambda in 1:n_lambda)
{
fit <- PEE_LI2(data=data_frame,method)
Fit_EN[i_lambda,] <- as.vector(fit$`beta SCAD`)
conv_mat[i_lambda] <- fit$diff_beta
}
colnames(Fit_EN) <- 1:10#no variable names in artificial example
max(conv_mat) #no convergence problems
#selection of variables not always zero
csum <- colSums(Fit_EN)
#sort on initial size
Fit_EN_select <- Fit_EN[,csum != 0]
volg <- order(abs(Fit_EN_select[1,]))
conv_mat <- vector(length=n_lambda)
Fit_plot <- Fit_EN_select[,rev(volg)]
k <- 0  #OLS initialization
#Different results for different lambda's
#Convergence
Fit_plot
lambda <- lambda_vec[i_lambda]
p <- 10    #number of variables (all numeric)
#plot tyhe 8 largest ones
distr <- "binomial"
linetype <- rep(c(1,2,6),100)
#beta1
plot(x=lambda_vec,y=Fit_plot[,1] ,
type='l',xlab=expression(lambda),ylab=expression(beta),
ylim=c(min(Fit_EN_select),max(Fit_EN_select)),lwd=2,lty=linetype[1], xlim = c(0.0085,0.5))
for(i in 2:10)
{
lines(x=lambda_vec,y=Fit_plot[,i],type='l',lwd=2,lty=linetype[i],log='x')
}
plot(x=lambda_vec,y=Fit_plot[,1] ,
type='l',xlab=expression(lambda),ylab=expression(beta),
ylim=c(min(Fit_EN_select),max(Fit_EN_select)),lwd=2,lty=linetype[1], xlim = c(0.0085,0.5))
data_frame <- Sim100N40P10u[[1]]#dataframe met [id,X,Y]
#settings)
library(matlab)
alpha <- 1 #Eén waarde voor alpha
n_lambda <- 100
lambda_vec <- linspace(0.0025,0.5,n=n_lambda)  #vector of
#PGEE functional settings
a <- 3.7
M_it <- 1000
tresh_beta <- 0.00001
M_diff <- 0.000000000001
k <- 0  #OLS initialization
option <- '' #non adaptive elastic net, no additional weights
method <- 'SCAD'  #method is elastic net as apposed to
p <- 10    #number of variables (all numeric)
distr <- "binomial"
#objecten
conv_mat <- vector(length=n_lambda)
Fit_EN <- array(dim=c(n_lambda,p))
#calculations
for(i_lambda in 1:n_lambda)
{
lambda <- lambda_vec[i_lambda]
fit <- PEE_LI2(data=data_frame,method)
Fit_EN[i_lambda,] <- as.vector(fit$`beta SCAD`)
conv_mat[i_lambda] <- fit$diff_beta
}
#Convergence
max(conv_mat) #no convergence problems
colnames(Fit_EN) <- 1:10#no variable names in artificial example
#selection of variables not always zero
csum <- colSums(Fit_EN)
Fit_EN_select <- Fit_EN[,csum != 0]
#sort on initial size
volg <- order(abs(Fit_EN_select[1,]))
Fit_plot <- Fit_EN_select[,rev(volg)]
#Different results for different lambda's
Fit_plot
#plot tyhe 8 largest ones
linetype <- rep(c(1,2,6),100)
#beta1
plot(x=lambda_vec,y=Fit_plot[,1] ,
type='l',xlab=expression(lambda),ylab=expression(beta),
ylim=c(min(Fit_EN_select),max(Fit_EN_select)),lwd=2,lty=linetype[1], xlim = c(0.0085,0.5))
for(i in 2:10)
{
lines(x=lambda_vec,y=Fit_plot[,i],type='l',lwd=2,lty=linetype[i],log='x')
}
plot(x=lambda_vec,y=Fit_plot[,1] ,
type='l',xlab=expression(lambda),ylab=expression(beta),
ylim=c(min(Fit_EN_select),max(Fit_EN_select)),lwd=2,lty=linetype[1], xlim = c(0.0085,0.5))
for(i in 2:10)
{
lines(x=lambda_vec,y=Fit_plot[,i],type='l',lwd=2,lty=linetype[i],log='x')
}
data_frame <- Sim100N40P10u[[2]]#dataframe met [id,X,Y]
#settings)
library(matlab)
alpha <- 1 #Eén waarde voor alpha
n_lambda <- 100
lambda_vec <- linspace(0.0025,2,n=n_lambda)  #vector of
#PGEE functional settings
a <- 3.7
M_it <- 1000
tresh_beta <- 0.00001
M_diff <- 0.000000000001
k <- 0  #OLS initialization
option <- '' #non adaptive elastic net, no additional weights
method <- 'SCAD'  #method is elastic net as apposed to
p <- 10    #number of variables (all numeric)
distr <- "binomial"
#objecten
conv_mat <- vector(length=n_lambda)
Fit_EN <- array(dim=c(n_lambda,p))
#calculations
for(i_lambda in 1:n_lambda)
{
lambda <- lambda_vec[i_lambda]
fit <- PEE_LI2(data=data_frame,method)
Fit_EN[i_lambda,] <- as.vector(fit$`beta SCAD`)
conv_mat[i_lambda] <- fit$diff_beta
}
#Convergence
max(conv_mat) #no convergence problems
colnames(Fit_EN) <- 1:10#no variable names in artificial example
#selection of variables not always zero
csum <- colSums(Fit_EN)
Fit_EN_select <- Fit_EN[,csum != 0]
#sort on initial size
volg <- order(abs(Fit_EN_select[1,]))
Fit_plot <- Fit_EN_select[,rev(volg)]
#Different results for different lambda's
Fit_plot
#plot tyhe 8 largest ones
linetype <- rep(c(1,2,6),100)
#beta1
plot(x=lambda_vec,y=Fit_plot[,1] ,
type='l',xlab=expression(lambda),ylab=expression(beta),
ylim=c(min(Fit_EN_select),max(Fit_EN_select)),lwd=2,lty=linetype[1],log='x', xlim = c(0.0085,2))
for(i in 2:10)
{
lines(x=lambda_vec,y=Fit_plot[,i],type='l',lwd=2,lty=linetype[i],log='x')
}
data_frame <- Sim100N40P10u[[1]]#dataframe met [id,X,Y]
data_frame <- Sim100N40P10u[[1]]#dataframe met [id,X,Y]
library(matlab)
alpha <- 1 #Eén waarde voor alpha
n_lambda <- 100
lambda_vec <- linspace(0.0025,2,n=n_lambda)  #vector of
#PGEE functional settings
a <- 3.7
M_it <- 1000
tresh_beta <- 0.00001
M_diff <- 0.000000000001
k <- 0  #OLS initialization
option <- '' #non adaptive elastic net, no additional weights
method <- 'SCAD'  #method is elastic net as apposed to
p <- 10    #number of variables (all numeric)
distr <- "binomial"
#objecten
conv_mat <- vector(length=n_lambda)
Fit_EN <- array(dim=c(n_lambda,p))
#calculations
for(i_lambda in 1:n_lambda)
{
lambda <- lambda_vec[i_lambda]
fit <- PEE_LI2(data=data_frame,method)
Fit_EN[i_lambda,] <- as.vector(fit$`beta SCAD`)
conv_mat[i_lambda] <- fit$diff_beta
}
#Convergence
max(conv_mat) #no convergence problems
colnames(Fit_EN) <- 1:10#no variable names in artificial example
#selection of variables not always zero
csum <- colSums(Fit_EN)
Fit_EN_select <- Fit_EN[,csum != 0]
#sort on initial size
volg <- order(abs(Fit_EN_select[1,]))
Fit_plot <- Fit_EN_select[,rev(volg)]
#Different results for different lambda's
Fit_plot
#plot tyhe 8 largest ones
linetype <- rep(c(1,2,6),100)
#beta1
plot(x=lambda_vec,y=Fit_plot[,1] ,
type='l',xlab=expression(lambda),ylab=expression(beta),
ylim=c(min(Fit_EN_select),max(Fit_EN_select)),lwd=2,lty=linetype[1],log='x', xlim = c(0.0085,2))
for(i in 2:10)
{
lines(x=lambda_vec,y=Fit_plot[,i],type='l',lwd=2,lty=linetype[i],log='x')
}
plot(x=lambda_vec,y=Fit_plot[,1] ,
type='l',xlab=expression(lambda),ylab=expression(beta),
ylim=c(min(Fit_EN_select),max(Fit_EN_select)),lwd=2,lty=linetype[1],log='x', xlim = c(0.0085,2))
for(i in 2:10)
{
lines(x=lambda_vec,y=Fit_plot[,i],type='l',lwd=2,lty=linetype[i],log='x')
}
data_frame <- Sim100N40P10u[[1]]#dataframe met [id,X,Y]
data_frame <- Sim100N40P10u[[1]]#dataframe met [id,X,Y]
#settings)
library(matlab)
alpha <- 1 #Eén waarde voor alpha
n_lambda <- 100
lambda_vec <- linspace(0.0025,2,n=n_lambda)  #vector of
#PGEE functional settings
a <- 3.7
M_it <- 1000
tresh_beta <- 0.00001
M_diff <- 0.000000000001
k <- 0  #OLS initialization
option <- '' #non adaptive elastic net, no additional weights
method <- 'SCAD'  #method is elastic net as apposed to
p <- 10    #number of variables (all numeric)
distr <- "binomial"
#objecten
conv_mat <- vector(length=n_lambda)
Fit_EN <- array(dim=c(n_lambda,p))
#calculations
for(i_lambda in 1:n_lambda)
{
lambda <- lambda_vec[i_lambda]
fit <- PEE_LI2(data=data_frame,method)
Fit_EN[i_lambda,] <- as.vector(fit$`beta SCAD`)
conv_mat[i_lambda] <- fit$diff_beta
}
#Convergence
max(conv_mat) #no convergence problems
colnames(Fit_EN) <- 1:10#no variable names in artificial example
#selection of variables not always zero
csum <- colSums(Fit_EN)
Fit_EN_select <- Fit_EN[,csum != 0]
#sort on initial size
volg <- order(abs(Fit_EN_select[1,]))
Fit_plot <- Fit_EN_select[,rev(volg)]
#Different results for different lambda's
Fit_plot
#plot tyhe 8 largest ones
linetype <- rep(c(1,2,6),100)
#beta1
plot(x=lambda_vec,y=Fit_plot[,1] ,
type='l',xlab=expression(lambda),ylab=expression(beta),
ylim=c(min(Fit_EN_select),max(Fit_EN_select)),lwd=2,lty=linetype[1],log='x', xlim = c(0.0085,2))
for(i in 2:10)
{
lines(x=lambda_vec,y=Fit_plot[,i],type='l',lwd=2,lty=linetype[i],log='x')
}
